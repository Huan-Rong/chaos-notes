# 并发编程的 Why，What，How
## 为什么使用并发

* 提高资源利用率
* 提升程序执行性能：利用日益普及的多核 CPU，来解决不断突破上限的系统并发量带来的问题

## 如何学习并发编程

> 并发编程并不是 Java 特有的语言特性，它是一个通用且早已成熟的领域。Java 只是根据自身情况作了实现罢了。

### 从学习的内容入手

* 掌握并发问题的本质
* 掌握操作系统领域的相关理论，如管程模型
* 站在理论模型的高度上理解 JDK 并发包
  * JDK 并发包只是针对并发问题开发出来的工具
* JDK 并发包的其他辅助工具：并发容器、原子类

## 什么是并发编程

![concurrency arch](./images/concurrency.png)

### 从分工、同步、互斥三个角度来理解并发编程

**并发编程可以总结为三个核心问题：分工、同步、互斥。**

* 分工，指的是如何高效地拆解任务并分配给线程
* 同步，指的是线程之间如何协作
* 互斥，指的是保证同一时刻只允许一个线程访问共享资源

分工、同步主要强调的是性能，互斥强调的是正确性，即线程安全。

#### 理解1

并发编程领域里，分工很重要，它直接决定了并发程序的性能。

从性能角度讲，我们为了提高执行一定计算机任务的效率，所以IO等待的时候不能让cpu闲着，所以我们把任务拆分交替执行，有了分时操作系统，出现了并发，后来cpu多核了又有了并行计算。这里也就是作者说的[分工]。分工以后我们为了进一步提升效率和更加灵活地达到目的，所以我们要对任务进行组织编排，也就是对线程组织编排。于是线程之间需要通信，于是操作系统提供了一些让进程，线程之间通信的方式。也就是作者说的[同步]。但是事物总不是完美的。并发和通信带来了较高的编程复杂度，同时也出现了多线程并发操作共享资源的问题。于是天下大势，分久必合，我们又要将对共享资源的访问串行化。所以我们根据现实世界的做法设计了了锁，信号量等等来补充这套体系。也就是作者所说的[互斥]！

综上，这一切均为提高性能的手段和对其所产生问题的解决方案。

#### 理解2

首先，得理解并发的重要性，为什么需要并发？对于这个问题，只需要放在潜意识里面，只需要两个字：性能！其它的细节，再去慢慢拓展。

然后，既然并发很重要，而并发处理的是任务，接下就是：对任务的抽象、拆解、分工执行。**而线程模型，只是其中的一种模型，还有多进程、协程。**Java使用的是多线程模型，对应到具体的代码就是：Thread, Runnable, Task，执行任务有：Exectors。 引出了线程，有势必存在着线程安全性的问题，因为多线程访问，数据存在着不一致的问题。

再然后，大的任务被拆解多个小的子任务，小的子任务被各自执行，不难想象，子任务之间肯定存在着依赖关系，所以需要协调，那如何协调呢？也不难想到，**锁是非常直接的方式(Monitor原理)，但是只用锁，协调的费力度太高，在并发的世界里面，又有了一些其它的更抽象的工具：闭锁、屏障、队列以及其它的一些并发容器等**；好了，协调的工作不难处理了。可是协调也会有出错的时候，这就有了死锁、活锁等问题，大师围绕着这个问题继续优化协调工具，尽量让使用者不容易出现这些活跃性问题；

到此，「并发」的历史还在演化：如果一遇到并发问题，就直接上锁，倒也没有什么大问题，可是追求性能是人类的天性。计算机大师就在思考，能不不加锁也能实现并发，还不容易出错，于是就有了：CAS、copy-on-write等技术思想，这就是实现了「无锁」并发；

可是，事情到此还没有完。如果以上这些个东西，都需要每个程序员自己去弄，然后自己保证正确性，那程序员真累死了，哪还有时间、精力创造这么多美好的应用！于是，计算机大师又开始思考，能不能抽象出统一「模型」，可能这就有了类似于「Java内存模型」这样的东西。

## 管程

管程是一种解决并发问题的模型，是继信号量模型之后的一项重大创新，它与信号量在逻辑上是等价的，即可以用管程实现信号量，也可以使用信号量实现管程。但是相比之下，管程更易于使用。

## 资源

* 《Java并发编程实战》作者阵容可谓大师云集，也包括Doug Lea
* 《Java并发编程的艺术》讲解并发包内部实现原理，能读明白，内功大增
* 《图解Java多线程设计模式》并发编程设计模式方面的经典书籍
* 《操作系统：精髓与设计原理》经典操作系统教材
* http://ifeve.com 国内专业并发编程网站
* http://www.cs.umd.edu/~pugh/java/memoryModel/ 很多并发编程的早期资料都在这里
