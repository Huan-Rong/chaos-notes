## 最好、最坏情况时间复杂度

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度。

最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度。
最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度。


## 平均情况时间复杂度

平均情况时间复杂度的全称是加权平均情况时间复杂度。我觉得这个全称是理解平均时间复杂度的关键：数据中的每个点对于平均数的贡献是不相等的，有些点要比其他点更加重要（参见维基：加权平均数）。

在这里，即不同情况下的时间复杂度出现的概率不同，有些情况的时间复杂度出现的概率更大。因此，使用加权的方式来计算所有情况下时间复杂度的平均值会更加合理。

## 均摊时间复杂度

均摊时间复杂度是一种特殊的平均时间复杂度，即也具备“不同情况下的时间复杂度出现的概率可能不同，有些情况的时间复杂度出现的概率可能更大”的特点。

但是，均摊时间复杂度在特定的应用场景下才能进行计算：在一组操作里，时间复杂度高的操作能够被均摊到其余时间复杂度低的操作上。对于均摊时间复杂度的理解，我感觉更多的是依靠感性/感觉，而非逻辑证明。

## 问题

在计算 insert 的平均时间复杂度时，为什么不是 1*1/2n + 1*1/2n + ... + 1*1/2n + n*1/2 = O(n) ? 也就是说为什么数组没有或者有空闲空间的概率不是 1/2 ?  为什么这跟计算 find 的平均时间复杂度不一样？

在计算均摊时间复杂度时，如何判断时间复杂度高的操作能够被其余时间复杂度低的操作均摊？

## 更多

思考：平均、加权平均、均摊
